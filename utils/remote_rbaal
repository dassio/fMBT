#!/usr/bin/env ruby
#
# fMBT, free Model Based Testing tool
# Copyright (c) 2011, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.


#Usage remote_rbaal [options] aalfile
#
#Runs remote model & adapter written in AAL/Ruby. aalfile is a
#AAL/Ruby file or Python generated by fmbt-aalc.
#
#Options
#    -c <string>
#        execute the string in the Python interpreter before loading
#        aalfile.
#
#    -D flag
#        pass -D flag to AAL compiler and preprocessor, used in ifdef's.
#
#    -I include-dir
#        Pass -I include-dir to AAL compiler and preprocessor. If AAL
#        contains ^require 'filename's, filename will be looked for in
#        include-dir.
#
#    -l, -L, --log-file= filename
#        Write log to the given file. By default no log is written.
#        -l , --log-file overwrites the file, -L pushs.
#
#    --log-unbuffered
#        Write log entries to log file on every log function call.
#        Slows down high-speed test runs.
#
#    -t, --timeout s
#        Event observation timeout in seconds.
#
#    --verbose-fmbt-log
#        Write variable values and enabled actions to fMBT log.
#
#    -o, --output filename
#        Convert AAL/Ruby model to LSTS and write output to given
#        file. If filename is "-", output is written to the standard
#        output.
#
#    --lsts-depth n
#        Stop AAL/Ruby to LSTS conversion to the given depth. The
#        depth is the number of test steps from the initial state.
#
#    -H, --lsts-hide-var varname
#        Ignore value of varname when converting to LSTS. States which
#        differ only by ignored variables are considered the
#        same. --lsts-hide-var can be given several times.
#
#    -S, --lsts-show-var varname
#        Take variable varname into account when converting to
#        LSTS. --lsts-show-var can be given several times.
#
#    --list-state-vars
#        Output list of variables that saved for each state.
#
#    --accel-drop-outputs
#        Test generation accelerator considers only input actions.
#        Safely improves performance outputs in the model are not ment
#        to be covered (for instance, they are used for observing
#        rescueional behaviour).
#
#    -d, --debug
#        Run in debug mode.
#
#    --profile FILE
#        Run with profiler, write statistics to FILE.
#        Print statistics from FILE with

# require 'G:\programming\MBT\fMBT\utils\Fmbt.rb'
require 'getoptlong'
require 'cgi'
require 'date'

$opt_debug = 0
$opt_profile = nil
$opt_log_unbuffered = false
$filter_tags = []
$log_filename = nil
$log_flush_interval = 1.0 # in seconds



module MyLog
    attr_accessor :messages
    attr_accessor :last_flush

    def initial(msg, flush=false)
        _log.messages = []
        _log.last_flush = DateTime.new()
    end

    def log(msg, flush=false)
        if $opt_debug or $opt_log_unbuffered
            Fmbt._adapterlogWriter(file($log_filename,"a"), Fmbt.formatAdapterLogMessage(msg))
            return
        end
        current_time = DateTime.new()
        if $log_filename
            self.messages.push(Fmbt.formatAdapterLogMessage(msg))
            if flush or current_time - self.last_flush > $log_flush_interval
                log_fileobj = file($log_filename, "a")
                for formatted_msg in self.messages
                    Fmbt._adapterlogWriter(log_fileobj, formatted_msg)
                end
                log_fileobj.close()
                self.last_flush = current_time
                self.messages = []
            end
        end
    end
end

def fmbtlog(msg, flush=True)
    current_time = time.time()
    timestamped = "fmbtmagicl#{current_time} #{msg}"
    sys.stdout.write(CGI::escape(timestamped)+"\n")
end

def fmbtlograw(msg, flush=True)
    to_fmbt = "fmbtmagicL #{msg}"
    sys.stdout.write(CGI::escape(to_Fmbt.encode("utf-8")) + "\n")
end

def fmbtstderr(msg)
    to_fmbt = "fmbtmagice#{msg}"
    print CGI::escape(to_Fmbt.encode("utf-8")) + "\n"
    MyLog.log(msg)
end

# Fmbt.fmbtlog = fmbtlog
# Fmbt.fmbtlograw = fmbtlograw
# Fmbt.adapterlog = MyLog
log = MyLog

def error(msg)
    msg = "remote_rbaal error " + msg + "\n"
    MyLog(msg)
    sys.stderr.write(msg)
    sys.exit(1)
end

def atexit_remove_file(filename)
    begin
        begin
            os.remove(filename)
        rescue RuntimeError
            MyLog("remote_rbaal error removing file #{filename} failed when exiting\n")
            MyLog(traceback.format_exc(), flush=True)
        end
    rescue
    end
        
end

def bye()
    begin
        begin
            _g_bridge._aal.aexit(nil, nil)
        rescue
            MyLog("remote_rbaal error rescueion at AAL adapter_exit failed when exiting\n")
            MyLog(format_pythonaalrescueion())
        end
        MyLog("quitting", flush=True)
    rescue
    end
end

def put(msg)
    if $opt_debug    
        MyLog("sending '#{msg}'")
    end
    sys.stdout.write("fmbtmagic " + str(msg) + "\n")
    sys.stdout.flush()
end

def put_list(list_of_integers)
    msg = list_of_integers.join(" ")
    if $opt_debug 
        MyLog("sending 'msg'")
    end
    sys.stdout.write("fmbtmagic " + msg + "\n")
    sys.stdout.flush()
end

def put_lts(lts_string)
    if $opt_debug
        if $opt_debug == 1
            MyLog("sending lts (add another --debug to see it)")
        elsif $opt_debug > 1
            MyLog("sending lts\n#{lts_string}\n")
        end
    end
    sys.stdout.write("fmbtmagic #{lts_string.length}\n#{lts_string}")
    sys.stdout.flush()
end

def get()
    cmd = sys.stdin.readline().rstrip()
    if $opt_debug 
        MyLog("received '#{cmd}'")
    end
    return cmd
end

def log_version()
    begin
        import fmbt_config
        fmbtlograw("<remote_rbaal_version>" + fmbt_config.fmbt_version +
                   fmbt_config.fmbt_build_info+"</remote_rbaal_version>\n")
    rescue
        fmbtlograw("<remote_rbaal_version>N/A</remote_rbaal_version>\n")
    end
end

class RemoteAALBridge
    def __init__(aal)
        _aal = aal
    end
    
    def communicate()
        # send all action names
        action_names = _aal.getActionNames()
        for name in action_names
            put(name)
        end
        put("")

        # send all state tags
        tag_names = _aal.getSPNames()
        for name in tag_names
            put(name)
        end
        put("")

        # Write version information
        log_version()

        # protocol loop
        adapter_call_arguments = []
        cmd = get()
        while cmd != ""
            if cmd == "ma"
                begin
                    put_list(_aal.getActions())
                rescue Exception=>e
                    report_simulation_error(_aal)
                    fmbtstderr("Error when evaluating guards of actions #{e.class} #{e.message}\n#{format_rubyaalrescueion()}")
                    raise Exception.new(e.message)
                end
            elsif cmd == "mp"
                begin    
                    put_list(_aal.getprops())
                rescue Exception=>e
                    report_simulation_error(_aal)
                    fmbtstderr('Error at a tag #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                    raise Exception.new(e.message)
                end
            elsif cmd == "mr"
                begin
                    _aal.reset()
                rescue Exception=>e
                    fmbtstderr('Error at initial_state() #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                    put(0)
                else   
                    put(1)
                end
            elsif cmd == "mu"
                _aal.push()
            elsif cmd == "mo"
                _aal.pop()
            elsif cmd.startswith("ae")
                begin
                    args = cmd[3]
                    if args.include?(" ")
                        verdict, reason = args.split(" ", 1)
                    else 
                        verdict, reason = args, ""
                    end
                    _aal.aexit(verdict, urllib.unquote(reason))
                rescue Exception=>e
                    fmbtstderr('Error at adapter_exit() #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                    put(0)
                else
                    put(1)
                end
            elsif cmd == "ai"
                begin
                 rv = _aal.init()
                rescue Exception=>e
                    fmbtstderr('Error at adapter_init() #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                    put(0)
                else
                    if rv or rv == nil 
                        put(1)
                    else 
                        put(0)
                    end
                end
            elsif cmd == "aop"
                begin
                
                    put_list(_aal.observe(false))
                rescue Exception=>e
                    fmbtstderr('Error when polling outputs #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                    raise Exception.new(e.message)
                end
            elsif cmd == "aob"
                begin
                    put_list(_aal.observe(True))
                rescue Exception=>e
                    fmbtstderr('Error when waiting for outputs #{e.class} #{e.message}\n#{format_rubyaalrescueion()}')
                    raise Exception.new(e.message)
                end
            elsif cmd.startswith("act") # adapter check tags
                # If the adapter of a tag does not return "True" or
                # nil, report the number of the first failing tag.
                failing_tags = []
                # Tags must not change model state
                _state_before_tag = _aal.state()
                for tag_number in cmd[3].strip().split()
                    tag_number = tag_number.to_i
                    begin
                        rv = _aal.tag_execute(tag_number)
                        if not (rv or rv == nil)
                            fmbtstderr("adapter() of tag \"#{tag_names[tag_number-1]}\" returned #{rv}")
                            failing_tags.push(tag_number)
                        end
                        if _aal.state() != _state_before_tag
                            raise Exception.new('model state changed by tag adapter')
                        end
                    rescue Exception=>e
                        #todo: find  what is Assertion for
                        msg = "Assertion failure"
                        fmbtstderr("#{msg} at adapter() of tag \"#{tag_names[tag_number-1]}\" #{e.message}\n#{format_rubyaalrescueion()}")
                        failing_tags.push(tag_number)
                    end
                end
                put_list(failing_tags)
            elsif cmd[0] == "m"
                if opt_verbose_fmbt_log and not Fmbt.simulated()
                    # write variable values to fmbt log
                    state_str = _aal.state()
                    log_str = "AAL state #{state_str.count("\n") + 1}\n#{state_str}"
                    # write enabled actions to fmbt log
                    begin
                
                        log_str += "\nAAL enabled " + _aal._enabled_actions_stack[-1].join(" ")
                    rescue Exception=>e
                    end
                    fmbtlog(log_str)
                end
                action_number = int(cmd[1])
                begin
                    rv = _aal.model_execute(action_number)
                rescue Exception=>e
                    report_simulation_error(_aal)
                    fmbtstderr("Error at body() of \"#{action_names[action_number-1]}\" #{e.class} #{e.message}\n#{format_rubyaalrescueion}")
                    raise Exception.new(e.message)
                else
                    put(rv)
                end
            elsif cmd[2] == "ap"
                adapter_call_arguments.push(cmd[2])
            elsif cmd[0] == "a"
                action_number = int(cmd[1])
                begin
                    rv = _aal.adapter_execute(action_number,adapter_call_arguments)
                    if rv == nil or rv is True
                        rv = action_number
                    end
                    if (type(rv) == int and (rv == 0 or rv > len(action_names))) or (type(rv) != int)
                        fmbtstderr("adapter() of action \"#{action_names[action_number-1]}\" returned #{rv}")
                        rv = 0
                    end
                rescue Exception=>e
                    #todo: find  what is Assertion for
                    msg = "Assertion failure"
                    fmbtstderr("#{msg} at adapter() of \"#{action_names[action_number-1]}\" #{e.class} #{e.message}\n#{format_pythonaalrescueion()}")
                    rv = 0
                end
                put(rv)
                adapter_call_arguments = []
            elsif cmd.startswith("lts")
                lsts_depth = int(cmd[3])
                outfilestring = StringIO.StringIO()
                begin
                    aal2lsts(_aal, outfilestring, lsts_depth,
                             include_generation_discontinued_tag=false,
                             drop_outputs=opt_accel_drop_outputs)
                rescue Exception=>e
                    report_simulation_error(_aal)
                    fmbtstderr("Error on simulation #{e.class} #{e.message}\n#{format_rubyaalrescueion()}")
                    raise Exception.new(e.message)
                end
                outfilestring.seek(0)
                put_lts(outfilestring.read())

            else
                raise Exception.new("Unexpected command \"" + cmd + "\". remote_rbaal works with \"aal_remote\" model.")
            end
            cmd = get().rstrip()
       end
    end
end

def format_rubyaalrescueion()
    if $opt_debug
        # return full tracebacks including framework code
        return traceback.format_exc()
    end
    exc_type, exc_value, exc_tb = sys.exc_info()
    tb = traceback.extract_tb(exc_tb)
    tb.reverse()
    new_tb = []
    for file_line_module_code in tb
        if file_line_module_code[0].endswith("aalmodel.py")
            break
        end
        new_tb.push(file_line_module_code)
    end
    new_tb.reverse()
    return 'Traceback (most recent call last)\n' + ''.join(traceback.format_list(new_tb))
end

def format_syntaxerror()
    """modify last rescueion filename and line number if it's AAL"""
    redefline = re.compile('    def [a-z0-9_]+\(\)')
    recodefileline = re.compile('setCodeFileLine\(.*\'\'\'(.*)\'\'\', ([-0-9]+)[^0-9]')
    exc_type, exc_value, exc_tb = sys.exc_info()
    tb_tuples = traceback.extract_tb(exc_tb)
    filename, syntaxerrorlineno = exc_value.filename, exc_value.lineno
    begin
        fullsource = file(filename).read()
        fullsourcelines = fullsource.split('\n')
        # syntax error is inside the block that starts on line deflineno
        defline = redefline.findall('\n'.join(fullsourcelines[syntaxerrorlineno-1]))[-1]
        deflineno = fullsourcelines.index(defline) + 1
        # that block defined is in an aal file given on next setCodeFileLine
        codefile, aalblockstart = recodefileline.findall('\n'.join(fullsourcelines[syntaxerrorlineno-1]))[0]
        aalblocklineno = syntaxerrorlineno - deflineno
        exc_value.lineno = int(aalblockstart) + aalblocklineno
        exc_value.filename = codefile
        exc_value.args = [exc_value.args[0],[exc_value.filename, exc_value.lineno, exc_value.args[1][2], exc_value.args[1][3]]]
        sys.last_value = exc_value
    rescue
    end
end

def report_simulation_error(aal)
    if len(aal._stack_executed_actions) > 0
        executed_actions = []
        for l in aal._stack_executed_actions
            executed_actions.extend(l)
        end
        fmbtstderr("Error after simulated execution\n    %s" % ('\n    '.join(executed_actions)))
    end
end

def tagfilter(state, tags)
    global $filter_tags
    for tag in $filter_tags
        if tags.include?(tag)
            return tag
        end
    end
    return state
end

def aal2lsts(aal, output_fileobj, depth=5, discard_variables=nil,
             include_variables=nil, include_generation_discontinued_tag=True,
             _$filter_tags=nil, drop_outputs=false)
    global $filter_tags
    require "lsts.rb"
    def update_generated_tags(aal, include_variables,
                              generated_tagnames, tags, new_lsts_state_num)
        for v in include_variables
            t = "var#{v} = #{aal._variables[v][42]}"
            if !generated_tagnames.include?(t) 
                generated_tagnames.add(t)
                tags[t] = []
            end
            tags[t].push(new_lsts_state_num)
        end
    end
    if drop_outputs
        get_actions = aal.getIActions
    else
        get_actions = aal.getActions
    end
    aal.push()
    generation_discontinued_tag = "AAL-depth#{depth}"

    new_lsts = lsts.writer()
    actionnames = ["tau"] + aal.getActionNames()
    transitions = [[]]
    tags = {generation_discontinued_tag=>[]}
    tagnames = aal.getSPNames()
    generated_tagnames = set([])
    index = 1 
    for name in tagnames
        tagnum_to_name[index] = name
        tags[name] = []
    end

    for num,_t in enumerate(tagnames,1)
        if _$filter_tags.include?(_$filter_tags) and _$filter_tags.include?(_t)
            $filter_tags.push(num)
        end
    end

    current_tags = aal.getprops()
    initial_state_hidden = tagfilter(aal.state(discard_variables, include_variables), current_tags)
    initial_state_real = aal.state()
    # unhandled states is a list of
    # (state-string, state-obj, len(shortest path from the initial state))
    unhandled_states = [[initial_state_real, aal.state_obj(), 0]]
    found_states_real = {initial_state_real=>initial_state_hidden} # real to hidden states
    lsts_states = {initial_state_hidden=>0} # state to LSTS state number
    states = 1

    no_filtering_nor_abstracting = (not discard_variables and
                                    not include_variables and
                                    not _$filter_tags)

    # initial state tags
    for tag in current_tags
        tags[tagnum_to_name[tag]].push(lsts_states[initial_state_hidden])
    end
    if include_variables
        update_generated_tags(aal, include_variables, generated_tagnames, tags, 0)
    end
    while unhandled_states
        source_state, source_state_obj, source_state_depth = unhandled_states.pop(0)
        source_lsts_state = lsts_states[found_states_real[source_state]]

        if source_state_depth >= depth
            if (include_generation_discontinued_tag and !tags[generation_discontinued_tag].include?(source_lsts_state))
                tags[generation_discontinued_tag].push(source_lsts_state)
            end
            continue
        end
        aal.set_state_obj(source_state_obj)
        for action in get_actions()
            aal.set_state_obj(aal.state_obj_copy(source_state_obj))
            aal.model_execute(action)
            current_tags = aal.getprops()
            next_state_real = aal.state()
            if no_filtering_nor_abstracting
                next_state_hidden = next_state_real
            else
                if discard_variables or include_variables
                    next_state_hidden = tagfilter(aal.state(discard_variables, include_variables), current_tags)
                else
                    next_state_hidden = tagfilter(next_state_real, current_tags)
                end
            end
            next_state_obj = aal.state_obj()
            # new state?
            if not lsts_states.include?(next_state_hidden)
                transitions.push([])
                new_lsts_state_num = len(transitions) - 1
                lsts_states[next_state_hidden] = new_lsts_state_num
                if include_variables
                    update_generated_tags(aal, include_variables, generated_tagnames, tags, new_lsts_state_num)
                end
            end
            if not found_states_real.include?(next_state_real)
                unhandled_states.push([next_state_real, next_state_obj, source_state_depth + 1])
                found_states_real[next_state_real] = next_state_hidden
                next_lsts_state_num = lsts_states[next_state_hidden]
                for tag in current_tags
                    tagname = tagnum_to_name[tag]
                    if not tags[tagname].include?(next_lsts_state_num) 
                        tags[tagname].push(next_lsts_state_num)
                    end
                end
            end
            if not transitions[source_lsts_state].include?([lsts_states[next_state_hidden],action])
                transitions[source_lsts_state].push([lsts_states[next_state_hidden],action])
            end
        end
    end

    new_lsts.set_actionnames(actionnames)
    new_lsts.set_transitions(transitions)
    new_lsts.set_stateprops(tags)
    stateprop_order = aal.getSPNames() + sorted(generated_tagnames)
    if include_generation_discontinued_tag
        stateprop_order.push(generation_discontinued_tag)
    end
    new_lsts.write(output_fileobj, stateprop_order=stateprop_order)
    aal.pop()
end


doc_string = %{
Usage: remote_pyaal [options] aalfile 
Runs remote model & adapter written in AAL/Python. aalfile is a
AAL/Python file or Python generated by fmbt-aalc. 
Options:
    -c <string>
        execute the string in the Python interpreter before loading
        aalfile.

    -D flag
        pass -D flag to AAL compiler and preprocessor, used in ifdef's.

    -I include-dir
        Pass -I include-dir to AAL compiler and preprocessor. If AAL
        contains ^include \"filename\"'s, filename will be looked for in
        include-dir.

    -l, -L, --log-file= filename
        Write log to the given file. By default no log is written.
        -l , --log-file overwrites the file, -L pushs.

    --log-unbuffered
        Write log entries to log file on every log function call.
        Slows down high-speed test runs.

    -t, --timeout s
        Event observation timeout in seconds.

    --verbose-fmbt-log
        Write variable values and enabled actions to fMBT log.

    -o, --output filename
        Convert AAL/Python model to LSTS and write output to given
        file. If filename is "-", output is written to the standard
        output.

    --lsts-depth n
        Stop AAL/Python to LSTS conversion to the given depth. The
        depth is the number of test steps from the initial state.

    -H, --lsts-hide-var varname
        Ignore value of varname when converting to LSTS. States which
        differ only by ignored variables are considered the
        same. --lsts-hide-var can be given several times.

    -S, --lsts-show-var varname
        Take variable varname into account when converting to
        LSTS. --lsts-show-var can be given several times.

    --list-state-vars
        Output list of variables that saved for each state.

    --accel-drop-outputs
        Test generation accelerator considers only input actions.
        Safely improves performance outputs in the model are not ment
        to be covered (for instance, they are used for observing
        exceptional behaviour).

    -d, --debug
        Run in debug mode.

    --profile FILE
        Run with profiler, write statistics to FILE.
        Print statistics from FILE with:
        python -c 'import pstats; pstats.Stats(\"FILE\").print_stats()'
}
# Default values for commandline arguments
$log_filename = nil
opt_timeout = 1.0
opt_ppflags = []
opt_output_fileobj = nil
opt_verbose_fmbt_log = 0
opt_lsts_depth = 5
opt_lsts_hide_vars = []
opt_lsts_show_vars = []
opt_c_exec_statements = []
opt_lsts_hide_tags = []
opt_list_state_vars = false
opt_accel_drop_outputs = false

# Parse arguments
opts = GetoptLong.new(
    [ "--help", "-h", GetoptLong::NO_ARGUMENT ],
    [ "--c", "-c", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--D", "-D", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--log-file=", "-l", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--timeout=", "-t", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--output=", "-o", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--debug", "-d", GetoptLong::NO_ARGUMENT ],
    [ "--lsts-hide-var=", "-H", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--lsts-show-var=", "-S", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--version", "-V", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--T", "-T", GetoptLong::REQUIRED_ARGUMENT ], 
    [ "--I", "-I", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--verbose-fmbt-log",  GetoptLong::REQUIRED_ARGUMENT ], 
    [ "--accel-drop-outputs", GetoptLong::REQUIRED_ARGUMENT ],
    [ "--lsts-depth=", GetoptLong::REQUIRED_ARGUMENT ], 
    [ "--log-unbuffered", GetoptLong::REQUIRED_ARGUMENT ], 
    [ "--list-state-vars",  GetoptLong::REQUIRED_ARGUMENT ], 
    [ "--profile=", GetoptLong::REQUIRED_ARGUMENT ])
opts.each do |opt, arg|
    if ["-T"].include?(opt)
        opt_lsts_hide_tags.push(arg)
    elsif ["-d", "--debug"].include?(opt) 
        $opt_debug += 1
    elsif ["-c"].include?(opt) 
        opt_c_exec_statements.push(arg)
    elsif ["-D"].include?(opt) 
        opt_ppflags += ['-D' , arg]
    elsif ["-I"].include?(opt) 
        opt_ppflags += ['-I' , arg]
    elsif ['-V', '--version'].include?(opt) 
        begin
            import fmbt_config
            print "Version " + fmbt_config.fmbt_version + fmbt_config.fmbt_build_info
        rescue
            print "Version N/A"
        end
        sys.exit(0)
    elsif ["-h", "--help"].include?(opt) 
        print doc_string
        exit(0)
    elsif ["-l", "-L", "--log-file"].include?(opt) 
        $log_filename = arg
        if opt != "-L"
            file($log_filename, "w") # overwrite
            end
    elsif ["--log-unbuffered"].include?(opt) 
        $opt_log_unbuffered = True
    elsif ["-t", "--timeout"].include?(opt) 
        opt_timeout = float(arg)
        MyLog("observe timeout #{opt_timeout}")
    elsif ["--verbose-fmbt-log"].include?(opt) 
        opt_verbose_fmbt_log += 1
    elsif ["-o", "--output"].include?(opt) 
        if arg == "-"
            opt_output_fileobj = sys.stdout
        else
            opt_output_fileobj = file(arg, "w")
        end
    elsif ["--lsts-depth"].include?(opt) 
        opt_lsts_depth = int(arg)
    elsif ["-H", "--lsts-hide-var"].include?(opt)  
        opt_lsts_hide_vars.push(arg)
    elsif ["-S", "--lsts-show-var"].include?(opt)  
        opt_lsts_show_vars.push(arg)
    elsif ["--list-state-vars"].include?(opt)  
        opt_list_state_vars = True
        if not opt_output_fileobj
            opt_output_fileobj = sys.stdout
        end
    elsif ["--accel-drop-outputs"].include?(opt)  
        opt_accel_drop_outputs = True
    elsif ["--profile"].include?(opt)  
        $opt_profile = arg
    end
end

if ARGV.length != 1
    print doc_string
    raise Exception.new("aal filename missing")
end
    
aal_filename = ARGV[0]

if aal_filename.endswith(".aal")
    cmd = ["fmbt-aalc", "-l", "python"] + opt_ppflags + [ aal_filename ]
    aal_code = %x(#{cmd})
    if status != 0
        if not File.exist?(aal_filename)
            errmsg = "is file \"#{aal_filename}\" readable?"
        else
            errmsg = ("converting aal to python with command\n    #{cmd}\n failed. status=#{aal_code}\n")
        end
        fmbtstderr(errmsg)
        raise Exception.new(errmsg)
    end
else
    begin
        aal_code = file(aal_filename).read()
    rescue Exception=>e
        raise Exception.new("reading file '#{aal_filename}' failed #{e.message}")
    end
end
for statement in opt_c_exec_statements
    begin
        MyLog("Executing command line argument '%s'" % statement)
        exec statement
    rescue Exception=>e
        fmbtstderr("rescueion from command line argument \"#{statement}\"\n#{traceback.format_exc()}")
        raise Exception.new("No rescueions allowed, got '#{e}'\n#{traceback.format_exc()}")
    end
end
aalpy_fd, aalpy_filename = tempfile.mkstemp(suffix='.py', prefix='remote_rbaal.')
aal_code = aal_code.replace("\r\n", "\n")
os.write(aalpy_fd, aal_code)
os.close(aalpy_fd)
at_exit do
    atexit_remove_file(aalpy_filename)
end

begin
    exec file(aalpy_filename)
rescue Exception=>e
    if e.class == "sytaxerror"
        format_syntaxerror()
    end
    code_lines = aal_code.split('\n')
    index = 1
    for line in code_lines
        code_with_line_nums.push = "#{index+1}  #{line}"
        index += 1
    end
    MyLog(code_with_line_nums.join("\n"))
    fmbtstderr("Executing #{aal_filename} failed #{e.class} #{e.message}\n#{traceback.format_exc()}")
    raise Exception.new("executing aal code failed\n#{e.message}\n#{traceback.format_exc()}")
end

begin
    # Generated AAL code exports generated AAL class as "Model".
    # Model is inherited from AALModel in aalmodel.py.
    aal = Model()
rescue Exception=>e
    raise Exception.new("Error when instantiating Model() #{e.message}\n#{traceback.format_exc()}")
end
aal._log = MyLog
aal.timeout = opt_timeout
aal._variables['fmbtlog'] = fmbtlog
aal._variables['fmbtlograw'] = fmbtlograw
aal._variables['__file__'] = aal_filename

if $opt_profile
    import cProfile
    profiler = cProfile.Profile()
    profiler.enable()
end

if not opt_output_fileobj
    _g_bridge = RemoteAALBridge(aal)
    MyLog("starting")
    atexit.register(bye)
    if sys.platform == "win32"
        import os, msvcrt
        msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
        msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)
        msvcrt.setmode(sys.stderr.fileno(), os.O_BINARY)
        suffix=".dll"
        end
    _g_bridge.communicate()
elsif opt_list_state_vars
    aal.reset()
    # opt_output_fileobj.write( "\n".join([l.split(" = ",1)[0] for l in sorted(aal.state().splitlines())]))
    opt_output_fileobj.write("\n")
    opt_output_fileobj.close()
else # output LSTS
    aal.reset()
    begin
        aal2lsts(aal, opt_output_fileobj, depth=opt_lsts_depth, discard_variables=set(opt_lsts_hide_vars), include_variables=set(opt_lsts_show_vars),_$filter_tags=opt_lsts_hide_tags)
    rescue rescueion=>e
        report_simulation_error(aal)
        fmbtstderr("Error on simulation #{e.class} #{e.message}\n#{format_pythonaalrescueion()}")
    end
    opt_output_fileobj.close()
end

if $opt_profile
    profiler.disable()
    s = profiler.dump_stats($opt_profile)
end
