#!/usr/bin/env ruby
#
# fMBT, free Model Based Testing tool
# Copyright (c) 2011, Intel Corporation.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms and conditions of the GNU Lesser General Public License,
# version 2.1, as published by the Free Software Foundation.
#
# This program is distributed in the hope it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
# more details.
#
# You should have received a copy of the GNU Lesser General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.


#Usage remote_rbaal [options] aalfile
#
#Runs remote model & adapter written in AAL/Ruby. aalfile is a
#AAL/Ruby file or Python generated by fmbt-aalc.
#
#Options
#    -c <string>
#        execute the string in the Python interpreter before loading
#        aalfile.
#
#    -D flag
#        pass -D flag to AAL compiler and preprocessor, used in ifdef's.
#
#    -I include-dir
#        Pass -I include-dir to AAL compiler and preprocessor. If AAL
#        contains ^require 'filename's, filename will be looked for in
#        include-dir.
#
#    -l, -L, --log-file= filename
#        Write log to the given file. By default no log is written.
#        -l , --log-file overwrites the file, -L appends.
#
#    --log-unbuffered
#        Write log entries to log file on every log function call.
#        Slows down high-speed test runs.
#
#    -t, --timeout s
#        Event observation timeout in seconds.
#
#    --verbose-fmbt-log
#        Write variable values and enabled actions to fMBT log.
#
#    -o, --output filename
#        Convert AAL/Ruby model to LSTS and write output to given
#        file. If filename is "-", output is written to the standard
#        output.
#
#    --lsts-depth n
#        Stop AAL/Ruby to LSTS conversion to the given depth. The
#        depth is the number of test steps from the initial state.
#
#    -H, --lsts-hide-var varname
#        Ignore value of varname when converting to LSTS. States which
#        differ only by ignored variables are considered the
#        same. --lsts-hide-var can be given several times.
#
#    -S, --lsts-show-var varname
#        Take variable varname into account when converting to
#        LSTS. --lsts-show-var can be given several times.
#
#    --list-state-vars
#        Output list of variables that saved for each state.
#
#    --accel-drop-outputs
#        Test generation accelerator considers only input actions.
#        Safely improves performance outputs in the model are not ment
#        to be covered (for instance, they are used for observing
#        rescueional behaviour).
#
#    -d, --debug
#        Run in debug mode.
#
#    --profile FILE
#        Run with profiler, write statistics to FILE.
#        Print statistics from FILE with

require "fmbt"
require 'getoptlong'
require 'cgi'

$opt_debug = 0
$opt_profile = nil
$opt_log_unbuffered = false
$filter_tags = []
$log_filename = nil
$log_flush_interval = 1.0 # in seconds

_log.messages = []
_log.last_flush = time.time()

def _log(msg, flush=false)
    if opt_debug or opt_log_unbuffered
        fmbt._adapterlogWriter(file($log_filename,"a"), fmbt.formatAdapterLogMessage(msg))
        return
    end
    current_time = time.time()
    if $log_filename
        _log.messages.append(fmbt.formatAdapterLogMessage(msg))
        if flush or current_time - _log.last_flush > log_flush_interval
            log_fileobj = file($log_filename, "a")
            for formatted_msg in _log.messages
                fmbt._adapterlogWriter(log_fileobj, formatted_msg)
            end
            log_fileobj.close()
            _log.last_flush = current_time
            _log.messages = []
        end
    end
end

def fmbtlog(msg, flush=True)
    current_time = time.time()
    timestamped = "fmbtmagicl#{current_time} #{msg}"
    sys.stdout.write(CGI::escape(timestamped)+"\n")
end

def fmbtlograw(msg, flush=True)
    to_fmbt = "fmbtmagicL #{msg}"
    sys.stdout.write(CGI::escape(to_fmbt.encode("utf-8")) + "\n")
end
def fmbtstderr(msg)
    to_fmbt = "fmbtmagice%s" % (msg,)
    sys.stdout.write(CGI::escape(to_fmbt.encode("utf-8")) + "\n")
    _log(msg)
end

fmbt.fmbtlog = fmbtlog
fmbt.fmbtlograw = fmbtlograw
fmbt.adapterlog = _log
log = _log

def error(msg)
    msg = "remote_rbaal error " + msg + "\n"
    _log(msg)
    sys.stderr.write(msg)
    sys.exit(1)
end

def atexit_remove_file(filename)
    begin
        begin
            os.remove(filename)
        rescue RuntimeError
            _log("remote_rbaal error removing file %s failed when exiting\n" % (repr(filename),))
            _log(traceback.format_exc(), flush=True)
        end
    rescue
    end
        
end

def bye()
    begin
        begin
            _g_bridge._aal.aexit(nil, nil)
        rescue
            _log("remote_rbaal error rescueion at AAL adapter_exit failed when exiting\n")
            _log(format_pythonaalrescueion())
        end
        _log("quitting", flush=True)
    rescue
    end
end

def put(msg)
    if opt_debug    
        _log("sending '%s'" % (msg,))
    end
    sys.stdout.write("fmbtmagic " + str(msg) + "\n")
    sys.stdout.flush()
end

def put_list(list_of_integers)
    msg = " ".join([str(i) for i in list_of_integers])
    if opt_debug 
        _log("sending '%s'" % (msg,))
    end
    sys.stdout.write("fmbtmagic " + msg + "\n")
    sys.stdout.flush()
end

def put_lts(lts_string)
    if opt_debug
        if opt_debug == 1
            _log("sending lts (add another --debug to see it)")
        elsif opt_debug > 1
            _log("sending lts\n%s\n" % (lts_string,))
        end
    end
    sys.stdout.write("fmbtmagic %s\n%s" % (len(lts_string), lts_string))
    sys.stdout.flush()
end

def get()
    cmd = sys.stdin.readline().rstrip()
    if opt_debug 
        _log("received '%s'" % (cmd,))
    end
    return cmd
end

def log_version()
    begin
        import fmbt_config
        fmbtlograw("<remote_rbaal_version>" + fmbt_config.fmbt_version +
                   fmbt_config.fmbt_build_info+"</remote_rbaal_version>\n")
    rescue
        fmbtlograw("<remote_rbaal_version>N/A</remote_rbaal_version>\n")
    end
end

class RemoteAALBridge
    def __init__(self, aal)
        self._aal = aal
    end
    
    def communicate(self)
        # send all action names
        action_names = self._aal.getActionNames()
        for name in action_names
            put(name)
        end
        put("")

        # send all state tags
        tag_names = self._aal.getSPNames()
        for name in tag_names
            put(name)
        end
        put("")

        # Write version information
        log_version()

        # protocol loop
        adapter_call_arguments = []
        cmd = get()
        while cmd != ""
            if cmd == "ma"
                begin
                    put_list(self._aal.getActions())
                rescue rescueion=>e
                    report_simulation_error(self._aal)
                    fmbtstderr('Error when evaluating guards of actions %s %s\n%s' % (type(e).__name__, e, format_pythonaalrescueion()))
                    error(str(e))
                end
            elsif cmd == "mp"
                begin    
                    put_list(self._aal.getprops())
                rescue rescueion=>e
                    report_simulation_error(self._aal)
                    fmbtstderr('Error at a tag %s %s\n%s' % (type(e).__name__, e, format_pythonaalrescueion()))
                    error(str(e))
                end
            elsif cmd == "mr"
                begin
                    self._aal.reset()
                rescue rescueion=>e
                    fmbtstderr('Error at initial_state() %s %s\n%s' % (type(e).__name__, e, format_pythonaalrescueion()))
                    put(0)
                else   
                    put(1)
                end
            elsif cmd == "mu"
                self._aal.push()
            elsif cmd == "mo"
                self._aal.pop()
            elsif cmd.startswith("ae")
                begin
                    args = cmd[3]
                    if " " in args 
                        verdict, reason = args.split(" ", 1)
                    else 
                        verdict, reason = args, ""
                    end
                    self._aal.aexit(verdict, urllib.unquote(reason))
                rescue rescueion=>e
                    fmbtstderr('Error at adapter_exit() %s %s\n%s' % (type(e).__name__, e, format_pythonaalrescueion()))
                    put(0)
                else
                    put(1)
                end
            elsif cmd == "ai"
                begin
                 rv = self._aal.init()
                rescue rescueion=>e
                    fmbtstderr('Error at adapter_init() %s %s\n%s' % (type(e).__name__, e, format_pythonaalrescueion()))
                    put(0)
                else
                    if rv or rv == nil 
                        put(1)
                    else 
                        put(0)
                    end
                end
            elsif cmd == "aop"
                begin
                
                    put_list(self._aal.observe(false))
                rescue rescueion=>e
                    fmbtstderr('Error when polling outputs %s %s\n%s' % (type(e).__name__, e, format_pythonaalrescueion()))
                    error(str(e))
                end
            elsif cmd == "aob"
                begin
                    put_list(self._aal.observe(True))
                rescue rescueion=>e
                    fmbtstderr('Error when waiting for outputs %s %s\n%s' % (type(e).__name__, e, format_pythonaalrescueion()))
                    error(str(e))
                end
            elsif cmd.startswith("act") # adapter check tags
                # If the adapter of a tag does not return "True" or
                # nil, report the number of the first failing tag.
                failing_tags = []
                # Tags must not change model state
                _state_before_tag = self._aal.state()
                for tag_number in [int(n) for n in cmd[3].strip().split()]
                    begin
                        rv = self._aal.tag_execute(tag_number)
                        if not (rv or rv == nil)
                            fmbtstderr('adapter() of tag "%s" returned %s' % (tag_names[tag_number-1], rv))
                            failing_tags.append(tag_number)
                        end
                        if self._aal.state() != _state_before_tag
                            raise rescueion('model state changed by tag adapter')
                        end
                    rescue rescueion=>e
                        if isinstance(e, AssertionError) 
                            msg = "Assertion failure"
                        else
                            msg = "Error"
                        end
                        fmbtstderr('%s at adapter() of tag "%s" %s\n%s' % (msg, tag_names[tag_number-1], e, format_pythonaalrescueion()))
                        if isinstance(e, AssertionError)
                            failing_tags.append(tag_number)
                        else
                            error(str(e))
                        end
                    end
                end
                put_list(failing_tags)
            elsif cmd[0] == "m"
                if opt_verbose_fmbt_log and not fmbt.simulated()
                    # write variable values to fmbt log
                    state_str = self._aal.state()
                    log_str = "AAL state %s\n%s" % (state_str.count("\n") + 1, state_str)
                    # write enabled actions to fmbt log
                    begin
                
                        log_str += "\nAAL enabled " + " ".join(
                            [str(s) for s in self._aal._enabled_actions_stack[-1]])
                    rescue IndexError
                    end
                    fmbtlog(log_str)
                end
                action_number = int(cmd[1])
                begin
                    rv = self._aal.model_execute(action_number)
                rescue rescueion=>e
                    report_simulation_error(self._aal)
                    fmbtstderr('Error at body() of "%s" %s %s\n%s' % (action_names[action_number-1], type(e).__name__, e, format_pythonaalrescueion()))
                    error(str(e))
                else
                    put(rv)
                end
            elsif cmd[2] == "ap"
                adapter_call_arguments.append(cmd[2])
            elsif cmd[0] == "a"
                action_number = int(cmd[1])
                begin
                    rv = self._aal.adapter_execute(action_number,adapter_call_arguments)
                    if rv == nil or rv is True
                        rv = action_number
                    end
                    if (type(rv) == int and (rv == 0 or rv > len(action_names))) or (type(rv) != int)
                        fmbtstderr('adapter() of action "%s" returned %s' % (action_names[action_number-1], rv))
                        rv = 0
                    end
                rescue rescueion=>e
                    if isinstance(e, AssertionError) 
                        msg = "Assertion failure"
                    else 
                        msg = "Error"
                    end
                    fmbtstderr('%s at adapter() of "%s" %s %s\n%s' % (msg, action_names[action_number-1], type(e).__name__, e, format_pythonaalrescueion()))
                    if isinstance(e, AssertionError)
                        rv = 0
                    else
                        error(str(e))
                    end
                end
                put(rv)
                adapter_call_arguments = []
            elsif cmd.startswith("lts")
                lsts_depth = int(cmd[3])
                outfilestring = StringIO.StringIO()
                begin
                    aal2lsts(self._aal, outfilestring, lsts_depth,
                             include_generation_discontinued_tag=false,
                             drop_outputs=opt_accel_drop_outputs)
                rescue rescueion=>e
                    report_simulation_error(self._aal)
                    fmbtstderr('Error on simulation %s %s\n%s' % (type(e).__name__, e, format_pythonaalrescueion()))
                    error(str(e))
                end
                outfilestring.seek(0)
                put_lts(outfilestring.read())

            else
                error("Unexpected command \"" + cmd + "\". remote_rbaal works with \"aal_remote\" model.")
            end
            cmd = get().rstrip()
       end
    end
end

def format_pythonaalrescueion()
    if opt_debug
        # return full tracebacks including framework code
        return traceback.format_exc()
    end
    exc_type, exc_value, exc_tb = sys.exc_info()
    tb = traceback.extract_tb(exc_tb)
    tb.reverse()
    new_tb = []
    for file_line_module_code in tb
        if file_line_module_code[0].endswith("aalmodel.py")
            break
        end
        new_tb.append(file_line_module_code)
    end
    new_tb.reverse()
    return 'Traceback (most recent call last)\n' + ''.join(traceback.format_list(new_tb))
end

def format_syntaxerror()
    """modify last rescueion filename and line number if it's AAL"""
    redefline = re.compile('    def [a-z0-9_]+\(\)')
    recodefileline = re.compile('setCodeFileLine\(.*\'\'\'(.*)\'\'\', ([-0-9]+)[^0-9]')
    exc_type, exc_value, exc_tb = sys.exc_info()
    tb_tuples = traceback.extract_tb(exc_tb)
    filename, syntaxerrorlineno = exc_value.filename, exc_value.lineno
    begin
        fullsource = file(filename).read()
        fullsourcelines = fullsource.split('\n')
        # syntax error is inside the block that starts on line deflineno
        defline = redefline.findall('\n'.join(fullsourcelines[syntaxerrorlineno-1]))[-1]
        deflineno = fullsourcelines.index(defline) + 1
        # that block defined is in an aal file given on next setCodeFileLine
        codefile, aalblockstart = recodefileline.findall('\n'.join(fullsourcelines[syntaxerrorlineno-1]))[0]
        aalblocklineno = syntaxerrorlineno - deflineno
        exc_value.lineno = int(aalblockstart) + aalblocklineno
        exc_value.filename = codefile
        exc_value.args = (exc_value.args[0],
                          (exc_value.filename, exc_value.lineno, exc_value.args[1][2], exc_value.args[1][3]))
        sys.last_value = exc_value
    rescue
    end
end

def report_simulation_error(aal)
    if len(aal._stack_executed_actions) > 0
        executed_actions = []
        for l in aal._stack_executed_actions
            executed_actions.extend(l)
        end
        fmbtstderr("Error after simulated execution\n    %s" % ('\n    '.join(executed_actions)))
    end
end

def tagfilter(state, tags)
    global filter_tags
    for tag in filter_tags
        if tag in tags
            return tag
        end
    end
    return state
end

def aal2lsts(aal, output_fileobj, depth=5, discard_variables=nil,
             include_variables=nil, include_generation_discontinued_tag=True,
             _filter_tags=nil, drop_outputs=false)
    global filter_tags
    begin
        import lsts
    rescue
        import fmbt.lsts as lsts
    end
    def update_generated_tags(aal, include_variables,
                              generated_tagnames, tags, new_lsts_state_num)
        for v in include_variables
            t = "var%s = %s" % (v, repr(aal._variables[v])[42])
            if not t in generated_tagnames
                generated_tagnames.add(t)
                tags[t] = []
            end
            tags[t].append(new_lsts_state_num)
        end
    end
    if drop_outputs
        get_actions = aal.getIActions
    else
        get_actions = aal.getActions
    end
    aal.push()
    generation_discontinued_tag = "AAL-depth%s" % (depth,)

    new_lsts = lsts.writer()
    actionnames = ["tau"] + aal.getActionNames()
    transitions = [[]]
    tags = {generation_discontinued_tag []}
    tagnames = aal.getSPNames()
    generated_tagnames = set([])
    tags.update([(name, []) for name in tagnames])
    tagnum_to_name = dict([(num+1, name) for num, name in enumerate(tagnames)])

    for num,_t in enumerate(tagnames,1)
        if _filter_tags and _t in _filter_tags
            filter_tags.append(num)
        end
    end

    current_tags = aal.getprops()
    initial_state_hidden = tagfilter(aal.state(discard_variables, include_variables), current_tags)
    initial_state_real = aal.state()
    # unhandled states is a list of
    # (state-string, state-obj, len(shortest path from the initial state))
    unhandled_states = [(initial_state_real, aal.state_obj(), 0)]
    found_states_real = {initial_state_real initial_state_hidden} # real to hidden states
    lsts_states = {initial_state_hidden 0} # state to LSTS state number
    states = 1

    no_filtering_nor_abstracting = (not discard_variables and
                                    not include_variables and
                                    not _filter_tags)

    # initial state tags
    for tag in current_tags
        tags[tagnum_to_name[tag]].append(lsts_states[initial_state_hidden])
    end
    if include_variables
        update_generated_tags(aal, include_variables, generated_tagnames, tags, 0)
    end
    while unhandled_states
        source_state, source_state_obj, source_state_depth = unhandled_states.pop(0)
        source_lsts_state = lsts_states[found_states_real[source_state]]

        if source_state_depth >= depth
            if (include_generation_discontinued_tag and
                not source_lsts_state in tags[generation_discontinued_tag])
                tags[generation_discontinued_tag].append(source_lsts_state)
            end
            continue
        end
        aal.set_state_obj(source_state_obj)
        for action in get_actions()
            aal.set_state_obj(aal.state_obj_copy(source_state_obj))
            aal.model_execute(action)
            current_tags = aal.getprops()
            next_state_real = aal.state()
            if no_filtering_nor_abstracting
                next_state_hidden = next_state_real
            else
                if discard_variables or include_variables
                    next_state_hidden = tagfilter(aal.state(discard_variables, include_variables), current_tags)
                else
                    next_state_hidden = tagfilter(next_state_real, current_tags)
                end
            end
            next_state_obj = aal.state_obj()
            # new state?
            if not next_state_hidden in lsts_states
                transitions.append([])
                new_lsts_state_num = len(transitions) - 1
                lsts_states[next_state_hidden] = new_lsts_state_num
                if include_variables
                    update_generated_tags(aal, include_variables, generated_tagnames, tags, new_lsts_state_num)
                end
            end
            if not next_state_real in found_states_real
                unhandled_states.append(
                    (next_state_real, next_state_obj, source_state_depth + 1))
                found_states_real[next_state_real] = next_state_hidden
                next_lsts_state_num = lsts_states[next_state_hidden]
                for tag in current_tags
                    tagname = tagnum_to_name[tag]
                    if not next_lsts_state_num in tags[tagname]
                        tags[tagname].append(next_lsts_state_num)
                    end
                end
            end
            if (lsts_states[next_state_hidden],action) not in transitions[source_lsts_state]
                transitions[source_lsts_state].append((lsts_states[next_state_hidden],action))
            end
        end
    end

    new_lsts.set_actionnames(actionnames)
    new_lsts.set_transitions(transitions)
    new_lsts.set_stateprops(tags)
    stateprop_order = aal.getSPNames() + sorted(generated_tagnames)
    if include_generation_discontinued_tag
        stateprop_order.append(generation_discontinued_tag)
    end
    new_lsts.write(output_fileobj, stateprop_order=stateprop_order)
    aal.pop()
end

if __name__ == "__main__"
    doc_string = "Usage: remote_pyaal [options] aalfile

Runs remote model & adapter written in AAL/Python. aalfile is a
AAL/Python file or Python generated by fmbt-aalc.

Options:
    -c <string>
        execute the string in the Python interpreter before loading
        aalfile.

    -D flag
        pass -D flag to AAL compiler and preprocessor, used in ifdef's.

    -I include-dir
        Pass -I include-dir to AAL compiler and preprocessor. If AAL
        contains ^include "filename"'s, filename will be looked for in
        include-dir.

    -l, -L, --log-file= filename
        Write log to the given file. By default no log is written.
        -l , --log-file overwrites the file, -L appends.

    --log-unbuffered
        Write log entries to log file on every log function call.
        Slows down high-speed test runs.

    -t, --timeout s
        Event observation timeout in seconds.

    --verbose-fmbt-log
        Write variable values and enabled actions to fMBT log.

    -o, --output filename
        Convert AAL/Python model to LSTS and write output to given
        file. If filename is "-", output is written to the standard
        output.

    --lsts-depth n
        Stop AAL/Python to LSTS conversion to the given depth. The
        depth is the number of test steps from the initial state.

    -H, --lsts-hide-var varname
        Ignore value of varname when converting to LSTS. States which
        differ only by ignored variables are considered the
        same. --lsts-hide-var can be given several times.

    -S, --lsts-show-var varname
        Take variable varname into account when converting to
        LSTS. --lsts-show-var can be given several times.

    --list-state-vars
        Output list of variables that saved for each state.

    --accel-drop-outputs
        Test generation accelerator considers only input actions.
        Safely improves performance outputs in the model are not ment
        to be covered (for instance, they are used for observing
        exceptional behaviour).

    -d, --debug
        Run in debug mode.

    --profile FILE
        Run with profiler, write statistics to FILE.
        Print statistics from FILE with:
        python -c 'import pstats; pstats.Stats("FILE").print_stats()'
"
    # Default values for commandline arguments
    $log_filename = nil
    opt_timeout = 1.0
    opt_ppflags = []
    opt_output_fileobj = nil
    opt_verbose_fmbt_log = 0
    opt_lsts_depth = 5
    opt_lsts_hide_vars = []
    opt_lsts_show_vars = []
    opt_c_exec_statements = []
    opt_lsts_hide_tags = []
    opt_list_state_vars = false
    opt_accel_drop_outputs = false

    # Parse arguments
    opts = GetoptLong.new(
        [ "--c","-c",GetoptLong::REQUIRED_ARGUMENT ],
        [ "--D","-D",GetoptLong::REQUIRED_ARGUMENT ],
        [ "--help","-h",GetoptLong::NO_ARGUMENT ],
        [ "--log-file=","-l",GetoptLong::REQUIRED_ARGUMENT ],
        [ "--log-file=","-L",GetoptLong::REQUIRED_ARGUMENT ],
        [ "--timeout=","-t",GetoptLong::REQUIRED_ARGUMENT ],
        [ "--output=","-o",GetoptLong::REQUIRED_ARGUMENT ],
        [ "--debug","-d",GetoptLong::NO_ARGUMENT ],
        [ "--lsts-hide-var=","-H",GetoptLong::REQUIRED_ARGUMENT ],
        [ "--lsts-show-var=","-S",GetoptLong::REQUIRED_ARGUMENT ]
        [ "--version","-V",GetoptLong::REQUIRED_ARGUMENT ]
        [ "--T","-T",GetoptLong::REQUIRED_ARGUMENT ]
        [ "--I","-I",GetoptLong::REQUIRED_ARGUMENT ]
        [ "--verbose-fmbt-log",'',GetoptLong::REQUIRED_ARGUMENT ],
        [ "--accel-drop-outputs",'',GetoptLong::REQUIRED_ARGUMENT ],
        [ "--lsts-depth=",'',GetoptLong::REQUIRED_ARGUMENT ],
        [ "--log-unbuffered",'',GetoptLong::REQUIRED_ARGUMENT ],
        [ "--list-state-vars",'',GetoptLong::REQUIRED_ARGUMENT ],
        [ "--profile=",'',GetoptLong::REQUIRED_ARGUMENT ])
    opts = getopt.gnu_getopt(
        sys.argv[1], 'cdhlLtoDHSVTI',
        ["debug", "help", "log-file=", "timeout=", "output=",
         "verbose-fmbt-log", "accel-drop-outputs",
         "lsts-depth=", "lsts-hide-var=", "lsts-show-var=",
         "log-unbuffered",
         "list-state-vars", "profile=", "version"])

    opts.each do |opt, arg|
        if opt in ["-T"]
            opt_lsts_hide_tags.append(arg)
        elsif opt in ["-d", "--debug"]
            opt_debug += 1
        elsif opt in ["-c"]
            opt_c_exec_statements.append(arg)
        elsif opt in ["-D"]
            opt_ppflags += ['-D' , arg]
        elsif opt in ["-I"]
            opt_ppflags += ['-I' , arg]
        elsif opt in ['-V', '--version']
            begin
                import fmbt_config
                print "Version " + fmbt_config.fmbt_version + fmbt_config.fmbt_build_info
            rescue
                print "Version N/A"
            end
            sys.exit(0)
        elsif opt in ["-h", "--help"]
            print doc_string
            sys.exit(0)
        elsif opt in ["-l", "-L", "--log-file"]
            $log_filename = arg
            if opt != "-L"
                file($log_filename, "w") # overwrite
             end
        elsif opt in ["--log-unbuffered"]
            opt_log_unbuffered = True
        elsif opt in ["-t", "--timeout"]
            opt_timeout = float(arg)
            _log("observe timeout %2.6f" % (opt_timeout,))
        elsif opt in ["--verbose-fmbt-log"]
            opt_verbose_fmbt_log += 1
        elsif opt in ["-o", "--output"]
            if arg == "-"
                opt_output_fileobj = sys.stdout
            else
                opt_output_fileobj = file(arg, "w")
            end
        elsif opt in ["--lsts-depth"]
            opt_lsts_depth = int(arg)
        elsif opt in ["-H", "--lsts-hide-var"]
            opt_lsts_hide_vars.append(arg)
        elsif opt in ["-S", "--lsts-show-var"]
            opt_lsts_show_vars.append(arg)
        elsif opt in ["--list-state-vars"]
            opt_list_state_vars = True
            if not opt_output_fileobj
                opt_output_fileobj = sys.stdout
            end
        elsif opt in ["--accel-drop-outputs"]
            opt_accel_drop_outputs = True
        elsif opt in ["--profile"]
            opt_profile = arg
        end
    end

    if ARGV.length != 1
        print doc_string
        raise Exception.new("aal filename missing")
    end
    
    aal_filename = ARGV[0]

    if aal_filename.endswith(".aal")
        cmd = ["fmbt-aalc", "-l", "python"] + opt_ppflags + [ aal_filename ]
        subout = subprocess.PIPE
        p = subprocess.Popen(cmd,shell=false, stdout=subout,stderr=subout)
        aal_code = p.stdout.read()
        status = p.wait()
        if status != 0
            if not os.access(aal_filename, os.R_OK)
                errmsg = 'is file "%s" readable?' % (aal_filename,)
            else
                errmsg = ("converting aal to python with command\n    %s\n"
                          "failed. status=%s\n%s\n" % (cmd, status, p.stderr.read()))
            end
            fmbtstderr(errmsg)
            error(errmsg)
        end
    else
        begin
            aal_code = file(aal_filename).read()
        rescue rescueion as e
            error("reading file '%s' failed %s" % (aal_filename, e))
        end
    end
    for statement in opt_c_exec_statements
        begin
            _log("Executing command line argument '%s'" % statement)
            exec statement
        rescue rescueion=>e
            fmbtstderr('rescueion from command line argument "%s"\n%s' %
                       (statement, traceback.format_exc()))
            error("No rescueions allowed, got '%s'\n%s" %
                  (e, traceback.format_exc()))
        end
    end
    aalpy_fd, aalpy_filename = tempfile.mkstemp(suffix='.py', prefix='remote_rbaal.')
    aal_code = aal_code.replace("\r\n", "\n")
    os.write(aalpy_fd, aal_code)
    os.close(aalpy_fd)
    atexit.register(lambda atexit_remove_file(aalpy_filename))

    begin
        exec file(aalpy_filename)
    rescue rescueion as e
        if isinstance(e, SyntaxError)
            format_syntaxerror()
        end
        code_lines = aal_code.split('\n')
        code_with_line_nums = ['%4s %s' % (num+1, line) for num,line in enumerate(code_lines)]
        _log('\n'.join(code_with_line_nums))
        fmbtstderr("Executing %s failed %s %s\n%s" %
                   (aal_filename, type(e).__name__, e, traceback.format_exc()))
        error("executing aal code failed\n%s\n%s" % (e, traceback.format_exc()))
    end
    
    begin
        # Generated AAL code exports generated AAL class as "Model".
        # Model is inherited from AALModel in aalmodel.py.
        aal = Model()
    rescue rescueion as e
        error("Error when instantiating Model() %s\n%s" % (e, traceback.format_exc()))
    end
    aal._log = _log
    aal.timeout = opt_timeout
    aal._variables['fmbtlog'] = fmbtlog
    aal._variables['fmbtlograw'] = fmbtlograw
    aal._variables['__file__'] = aal_filename

    if opt_profile
        import cProfile
        profiler = cProfile.Profile()
        profiler.enable()
    end
    
    if not opt_output_fileobj
        _g_bridge = RemoteAALBridge(aal)
        _log("starting")
        atexit.register(bye)
        if sys.platform == "win32"
            import os, msvcrt
            msvcrt.setmode(sys.stdin.fileno(), os.O_BINARY)
            msvcrt.setmode(sys.stdout.fileno(), os.O_BINARY)
            msvcrt.setmode(sys.stderr.fileno(), os.O_BINARY)
            suffix=".dll"
         end
        _g_bridge.communicate()
    elsif opt_list_state_vars
        aal.reset()
        opt_output_fileobj.write( "\n".join([l.split(" = ",1)[0] for l in sorted(aal.state().splitlines())]))
        opt_output_fileobj.write("\n")
        opt_output_fileobj.close()
    else # output LSTS
        aal.reset()
        begin
            aal2lsts(aal, opt_output_fileobj, depth=opt_lsts_depth, discard_variables=set(opt_lsts_hide_vars), include_variables=set(opt_lsts_show_vars),_filter_tags=opt_lsts_hide_tags)
        rescue rescueion=>e
            report_simulation_error(aal)
            fmbtstderr('Error on simulation %s %s\n%s' % (type(e).__name__, e, format_pythonaalrescueion()))
        end
        opt_output_fileobj.close()
    end
    
    if opt_profile
        profiler.disable()
        s = profiler.dump_stats(opt_profile)
    end
end
